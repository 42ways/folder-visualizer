#!/usr/bin/env python3
# 
# Copyright (c) 2022 Thomas Herrmann, 42ways GmbH
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import argparse
import os
import sys

def visualise_tree(args):
    with open(args.output, 'w') as output:
        try:
            output.writelines(
                [ '@startuml\n\n',
                '\' Generated by folder-visializer (https://github.com/42ways/folder-visualizer)\n',
                '\' Script was called like:\n',
                '\' ', " ".join(sys.argv[:]), '\n',
                '\n'
                ])
            traverse_tree(output, args)
            output.write('\n@enduml\n')
        finally:
            output.close()


def canonical_name(name):
    return name.replace('/', '_').replace('-', '_').replace('@', '_')


# adapted from https://stackoverflow.com/a/1094933
def sizeof_fmt(num, binary=True):
    factor = 1024.0 if binary else 1000.0
    suffix = 'iB' if binary else 'B'
    if abs(num) < factor:
        return f'{num:3.0f} bytes'
    for unit in ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z']:
        if abs(num) < factor:
            return f'{num:3.1f} {unit}{suffix}'
        num /= factor
    return f'{num:.1f} Y{suffix}'


def traverse_tree(output, args):
    for dir_path, dir_names, filenames in os.walk(args.root.rstrip(os.path.sep), followlinks=args.followlinks):
        output.write(f'folder {canonical_name(dir_path)} [\n<b>{os.path.basename(dir_path)}</b>\n')
        if args.count:
            output.write(f'{len(filenames)} files\n')
        if args.size_unit:
            size = sum(os.path.getsize(dir_path + os.path.sep + f) for f in filenames)
            output.write(f'{sizeof_fmt(size, args.size_unit == "B")}\n')
        output.write(f']\n')
        parent_path = os.path.dirname(dir_path)
        if len(parent_path) > 0:
            output.write(f'{canonical_name(parent_path)} -- {canonical_name(dir_path)}\n')
        cur_depth = dir_path.count(os.path.sep)
        if 0 <= args.max_depth <= cur_depth:
            del dir_names[:]
        for dir in args.ignored_dirs:
            if dir in dir_names:
                dir_names.remove(dir)


def main():
    parser = argparse.ArgumentParser(description='Traverse a directory tree and create an PlantUML source file '
                                                 'to visualize it graphically')
    parser.add_argument('root', default='.', nargs='?',
                        help='root directory of tree traversal (default ".")')
    parser.add_argument('-f', '--follow-symlinks', dest='followlinks', action='store_true',
                        help='follow symbolic links')
    parser.add_argument('-m', '--max-depth', dest='max_depth', metavar='depth', default=-1, type=int,
                        help='maximal tree depth to traverse')
    parser.add_argument('-i', '--ignore', dest='ignored_dirs', metavar='dir', action='append', default=[],
                        help='ignore directory in traversal (may be specified more than once)')
    parser.add_argument('-c', '--count', dest='count', action='store_true',
                        help='include number of files per folder')
    parser.add_argument('-s', '--size', dest='size_unit', metavar='unit', nargs='?', const='B', choices=['B', 'D'],
                        help='include size of files per folder (unit is "B" for binary (default) or "D" for decimal)')
    parser.add_argument('-o', '--output', dest='output', default='folder-tree.puml', metavar='filename',
                        help='name of output file (default folder-tree.puml)')
    parser.add_argument('--version', action='version', version='%(prog)s 0.1')
    args = parser.parse_args()
    visualise_tree(args)


if __name__ == '__main__':
    main()
